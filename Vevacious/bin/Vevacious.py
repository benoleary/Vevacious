# This Python program was automatically generated by Vevacious, a program
# released under the GNU General Public License, and, as such, this program
# is also under the GNU General Public License. Please see the
# README.Vevacious.txt file accompanying the Vevacious C++ code for a full
# list of files, brief documentation, and further details on the license.
#
# Vevacious authors: Ben O'Leary (benjamin.oleary@gmail.com)
#                    Florian Staub (florian.staub@googlemail.com)
#                    Jose' Eliel Camargo Molina (elielx@gmail.com)
#                    Werner Porod (porod@physik.uni-wuerzburg.de)
#
#      Copyright 2012 Ben O'Leary, Florian Staub,
#                     Jose' Eliel Camargo Molina, Werner Porod
#
# (B.O'L. would like to apologize about the state of this file: ideally it
# would be a lot neater, and respect modern programming practices. However,
# it ended up easier to try to keep all this in one file. Maybe a later
# version will tidy it up properly, maybe splitting it into separate
# files...)
#
#
from __future__ import division
import math
import numpy
import numpy.linalg
import minuit
import VevaciousParameterDependent as VPD
import VevaciousTreeLevelExtrema as VTE


treeLevelExtrema = VTE.pointsToTry
vcs = VPD.Vevacious(
                EffectivePotential = VPD.LoopAndThermalCorrectedPotential )
# Various settings can be changed here: e.g. to use the tree-level
# potential for minimizing and tunneling, one could use
# EffectivePotential = VPD.TreeLevelPotential
# Even a custom potential function can be inserted here, as long as it
# takes the correct arguments.
vcs.allowedRunningTime = 3600.0
# Allowing an hour of running time is maybe excessive...

# WriteExtrema is not important for deciding whether a parameter point is
# metastable, but it helps with debugging.
vcs.WriteExtrema( treeLevelExtrema, "Vevacious_tree-level_extrema.txt" )

# RollExtrema includes the automatic nudging off saddle points according to
# vcs.nudgeList.
# It also sorts the minima and sets vcs.panicVacuum and vcs.globalMinimum,
# and vcs.dsbVacuumIsMetastable.
vcs.RollExtrema( treeLevelExtrema )
print( "DSB vacuum: " + vcs.ExtremumAsMathematica( vcs.dsbVacuum ) )

# WriteMinima is also not important for deciding whether a parameter point
# is metastable, but it helps with debugging.
vcs.WriteMinima( "Vevacious_loop-corrected_minima.txt" )

quantumTunnelingActionType = "not_set_error"
quantumStabilityVerdict = "not_set_error"
thermalStabilityVerdict = "not_set_error"
finalQuantumAction = None
exclusionTemperature = None
exclusionTemperatureString = "not_set_error"
quantumTunnelingTimeInUniverseAgesString = "not_set_error"
thermalTunnelingSurvivalProbabilityString = "not_set_error"


if ( not vcs.dsbVacuumIsMetastable ):
    print( "DSB vacuum is stable (as far as the model file allows)." )
    quantumTunnelingActionType = "unnecessary"
    quantumStabilityVerdict = "stable"
    thermalStabilityVerdict = "stable"
    exclusionTemperatureString = "unnecessary"
    quantumTunnelingTimeInUniverseAgesString = "-1.0"
    thermalTunnelingSurvivalProbabilityString = "1.0"
else:
# The deepest minimum found by vcs.RollExtrema is recorded as
# vcs.globalMinimum and it may happen to correspond to the DSB minimum.
# If there were minima found which are deeper than the DSB minimum, the one
# closest to the DSB minimum (or reflections of it in any field value, as
# the potential may be invariant under a set of sign flips of the fields)
# is recorded as the panic vacuum, in vcs.panicVacuum. The panic vacuum
# does not necessarily correspond to vcs.globalMinimum. Strictly, all
# minima should be checked for tunneling, but it is computationally
# expensive, and it seems that for points of phenomenological interest, the
# bubble wall is the dominant term so the closest minima are more likely to
# have the lowest actions.
    print( "Panic vacuum: "
           + vcs.ExtremumAsMathematica( vcs.panicVacuum ) )
    print( "Global minimum found: "
           + vcs.ExtremumAsMathematica( vcs.globalMinimum )
           + "\n\n" )
    quantumStabilityVerdict = "long-lived"
    thermalStabilityVerdict = "high_survival_probability"
# First, a direct path between the minima is taken to get an upper bound on
# the bounce action.
    vcs.SetTemperature( 0.0 )
    currentQuantumAction = vcs.CalculateAction(
                                               falseVacuum = vcs.dsbVacuum,
                                              trueVacuum = vcs.panicVacuum,
                                                deformPath = False,
                                                thermalNotQuantum = False )
    print( "Direct path zero-temperature 4-dimensional action is "
           + str( currentQuantumAction )           + "\n\n" )
    exclusionTemperature = 0.0
    quantumTunnelingActionType = "direct_path"
    thermalTunnelingSurvivalProbabilityString = "not_calculated"
    if ( currentQuantumAction > vcs.quantumActionThreshold ):
# If the parameter point is not excluded by the naive straight path at zero
# temperature, then we check thermal tunneling by direct paths to see if
# a direct path can exclude the point, & to get an estimate of what
# temperature to use for a full calculation with path deformation.
        print( "Upper bound on zero-temperature full effective action by"
               + " direct path is too high to exclude point, so trying"
               + " direct paths at non-zero temperatures." )
        currentThermalAction = vcs.CalculateAction(
                                               falseVacuum = vcs.dsbVacuum,
                                              trueVacuum = vcs.panicVacuum,
                                                    deformPath = False,
                                                 thermalNotQuantum = True )
        print( "[3-dimensional action at T = 0.0 is "
               + str( currentThermalAction ) + "]" )
        thermallyExcluded = False
        temperaturesWithThermalActions = []
        thermalMinimaWithTemperatures = []
# We try to take a shortcut by parameterizing the thermal action as a
# polynomial in the temperature, so that we can estimate the most
# constraining temperature for a final proper calculation. Of course, if
# any thermal action calculated in the process already excludes the
# parameter point, the rest of the calculation will be skipped.
# We take the zero-temperature path for the constant part:
        temperaturesWithThermalActions.append( [ 0.0,
                                               currentThermalAction ] )
        thermalMinimaWithTemperatures.append(
                                            { "dsbVacuum": vcs.dsbVacuum,
                                          "panicVacuum": vcs.panicVacuum,
                                              "temperatureValue": 0.0 } )
# Next we estimate at what temperature tunneling to the panic vacuum
# becomes impossible. As a 1st guess, we take the temperature such that the
# SM thermal corrections at zero VEVs would equal the difference:
        potentialDifference = ( vcs.dsbVacuum[  "PotentialValue" ]
                                - vcs.panicVacuum[  "PotentialValue" ] )
# The corrections are ( T^4 / ( 2 pi^2 ) ) * sum of J functions, and the
# values of the J functions are about 2 for massless bosonic & fermionic
# degrees of freedom, & there are ~100 degrees of freedom in the SM. Hence
# we take the coefficient of T^4  to be 100 / ( 2 pi^2 ) ~= 5
        criticalTemperatureGuess = math.pow( ( potentialDifference / 5.0 ),
                                             0.25 )
# We aim to have a pair of temperatures, one above the critical
# temperature, the other below (rather than hunting for the exact critical
# temperature, which is not so important for our purposes). If the initial
# guess was below the critical temperature, we start doubling the
# temperature, recording the previous temperature each time. If it was
# above, we start halving the temperature, recording the previous
# temperature each time.
        print( "Searching for critical temperature.\n\n" )

        def RollVacuaAtTemperature( temperatureGuess ):
            print( "Trying " + str( temperatureGuess ) + " GeV.\n" )
            vcs.SetTemperature( temperatureGuess )
            print( "DSB vacuum:" )
            newThermalDsbVacuum = vcs.TryToMinimize( vcs.dsbVacuum[
                                                        "FieldValues" ] )
            print( "Panic vacuum:" )
            newThermalPanicVacuum = vcs.TryToMinimize( vcs.panicVacuum[
                                                        "FieldValues" ] )
            return [ newThermalDsbVacuum, newThermalPanicVacuum ]

        minimumSeparationSquared = ( (0.1)**2
                                     * numpy.sum( (vcs.dsbArray)**2 ) )

        def MinimaAreDistinct( firstMinimum, secondMinimum ):
            firstArray = VPD.FieldDictionaryToArray( firstMinimum[
                                                        "FieldValues" ] )
            secondArray = VPD.FieldDictionaryToArray( secondMinimum[
                                                        "FieldValues" ] )
            firstLengthSquared = numpy.sum( firstArray**2 )
            secondLengthSquared = numpy.sum( secondArray**2 )
            shorterLengthSquared = firstLengthSquared
            if ( firstLengthSquared > secondLengthSquared ):
                shorterLengthSquared = secondLengthSquared
            if ( shorterLengthSquared < minimumSeparationSquared ):
                shorterLengthSquared = minimumSeparationSquared
            differenceLengthSquared = numpy.sum( ( firstArray
                                                   - secondArray )**2 )
            return ( differenceLengthSquared > ( (0.2)**2
                                                 * shorterLengthSquared ) )

        def TunnelingPossible( falseVacuum, trueVacuum ):
            return ( MinimaAreDistinct( falseVacuum, trueVacuum )
                     and
                     ( falseVacuum[ "PotentialValue" ] > trueVacuum[
                                                   "PotentialValue" ] ) )

        thermalDsbVacuum, thermalPanicVacuum = RollVacuaAtTemperature(
                                                 criticalTemperatureGuess )
        while not TunnelingPossible( thermalDsbVacuum,
                                     thermalPanicVacuum ):
            criticalTemperatureGuess = ( 0.5 * criticalTemperatureGuess )
            thermalDsbVacuum, thermalPanicVacuum = RollVacuaAtTemperature(
                                                 criticalTemperatureGuess )
# At this point, criticalTemperatureGuess is definitely below the critical
# temperature. Now we look for the critical temperature from below:
        while TunnelingPossible( thermalDsbVacuum, thermalPanicVacuum ):
            thermalMinimaWithTemperatures.append(
                                            { "dsbVacuum": vcs.dsbVacuum,
                                          "panicVacuum": vcs.panicVacuum,
                         "temperatureValue": criticalTemperatureGuess } )
            criticalTemperatureGuess = ( 2.0 * criticalTemperatureGuess )
            thermalDsbVacuum, thermalPanicVacuum = RollVacuaAtTemperature(
                                                 criticalTemperatureGuess )
# At this point, highestTemperatureTunneling[ "temperatureValue" ] should
# be between 0.5 & 1.0 times the critical temperature.
        criticalTemperatureGuess = ( 0.5 * math.sqrt( 2.0 )
                                     * criticalTemperatureGuess )
        thermalDsbVacuum, thermalPanicVacuum =  RollVacuaAtTemperature(
                                                 criticalTemperatureGuess )
        if TunnelingPossible( thermalDsbVacuum, thermalPanicVacuum ):
            thermalMinimaWithTemperatures.append(
                                            { "dsbVacuum": vcs.dsbVacuum,
                                          "panicVacuum": vcs.panicVacuum,
                         "temperatureValue": criticalTemperatureGuess } )
# At this point,
# thermalActionsWithTemperatures[ -1 ][ "temperatureValue" ]
# should be within a factor of the square root of two times the critical
# temperature.
        highestTemperature = thermalMinimaWithTemperatures[ -1 ][
                                                     "temperatureValue" ]
        trialTemperatures = [ 0.5 * highestTemperature,
                              1.0 * highestTemperature ]
        thermalDsbVacuum = vcs.dsbVacuum
        thermalPanicVacuum = vcs.panicVacuum
# The thermal action is calculated for a discrete set of temperatures,
# which must be ordered from lowest to highest.
        for trialTemperature in trialTemperatures:
            vcs.SetTemperature( trialTemperature )
            thermalDsbVacuum = vcs.TryToMinimize( thermalDsbVacuum[
                                                        "FieldValues" ] )
            thermalPanicVacuum = vcs.TryToMinimize( thermalPanicVacuum[
                                                        "FieldValues" ] )
            currentThermalAction = vcs.CalculateAction(
                                            falseVacuum = thermalDsbVacuum,
                                           trueVacuum = thermalPanicVacuum,
                                                        deformPath = False,
                                                 thermalNotQuantum = True )
            if ( currentThermalAction < vcs.thermalActionThreshold ):
# If the action at a given temperature is low enough that the DSB vacuum
# (or the symmetric vacuum that becomes the DSB vacuum through a 2nd-order
# phase transition) is unlikely to have survived the time when the Universe
# was at about that temperature, no further calculation is made.
                print( "Parameter point is excluded by thermal tunneling"
                       + " at temperature "
                       + str( trialTemperature )
                       + " GeV." )
                thermallyExcluded = True
                exclusionTemperature = trialTemperature
                thermalTunnelingSurvivalProbabilityString = str(
                                   vcs.ThermalTunnelingSurvivalProbability(
                                                      exclusionTemperature,
                                                   currentThermalAction ) )
                print( "Thermal tunneling survival probability = "
                       + thermalTunnelingSurvivalProbabilityString )

            print( "\nDirect path 3-dimensional action at temperature "
                   + str( trialTemperature )
                   + " GeV is "
                   + str( currentThermalAction )
                   + " GeV.\n\n" )
            temperaturesWithThermalActions.append( [ trialTemperature,
                                                   currentThermalAction ] )
# End of loop over trialTemperatures

        if not thermallyExcluded:
# If the parameter point was not excluded, we attempt to minimize the
# costly calculation of the deformed action by guessing the optimal
# temperature so that we only deform the path for that temperature. The
# inverse of the action is fitted to a quadratic polynomial in the
# temperature and then this is used for an analytic calculation of the
# survival probability from the highest temperature in the list down to the
# lowest.
# Fitting a (T/Q)^2 + b (T/Q) + c to the inverses of the actions at
# T/Q = 0.0, 0.5, and 1.0 leads to:
            inverseActionAtZero = ( 1.0
                               / temperaturesWithThermalActions[ 0 ][ 1 ] )
            inverseActionAtHalf = ( 1.0
                               / temperaturesWithThermalActions[ 1 ][ 1 ] )
            inverseActionAtOne = ( 1.0
                               / temperaturesWithThermalActions[ 2 ][ 1 ] )
            quadraticCoefficient = ( ( 2.0 * ( inverseActionAtZero
                                            - ( 2.0 * inverseActionAtHalf )
                                             + inverseActionAtOne ) )
                                     / ( highestTemperature
                                         * highestTemperature ) )
            linearCoefficient = ( ( ( 4.0 * inverseActionAtHalf )
                                    - ( 3.0 * inverseActionAtZero )
                                    - inverseActionAtOne )
                                  / highestTemperature )
            constantTerm = inverseActionAtZero

            print( "(1/S_3) parameterized as ("
                   + str( quadraticCoefficient )
                   + ") T^2 + ("
                   + str( linearCoefficient )
                   + ") T + ("
                   + str( constantTerm )
                   + ")\n\n" )

            def LowestAction( givenTemperaturesWithActions ):
# The addition of 1.0 to the temperatures is to prevent division by zero.
                lowRatio = ( givenTemperaturesWithActions[ 0 ][ 1 ]
                       / ( givenTemperaturesWithActions[ 0 ][ 0 ] + 1.0 ) )
                middleRatio = ( givenTemperaturesWithActions[ 1 ][ 1 ]
                       / ( givenTemperaturesWithActions[ 1 ][ 0 ] + 1.0 ) )
                highRatio = ( givenTemperaturesWithActions[ 2 ][ 1 ]
                       / ( givenTemperaturesWithActions[ 2 ][ 0 ] + 1.0 ) )
                if ( ( highRatio < middleRatio )
                     and
                     ( highRatio < lowRatio ) ):
                    return [ givenTemperaturesWithActions[ 2 ][ 0 ],
                                   givenTemperaturesWithActions[ 2 ][ 1 ] ]
                elif ( middleRatio < lowRatio ):
                    return [ givenTemperaturesWithActions[ 1 ][ 0 ],
                                   givenTemperaturesWithActions[ 1 ][ 1 ] ]
                else:
                    return [ givenTemperaturesWithActions[ 0 ][ 0 ],
                                   givenTemperaturesWithActions[ 0 ][ 1 ] ]

            if ( ( constantTerm <= 0.0 )
                or
                ( quadraticCoefficient >= 0.0 ) ):
                print ( "Quadratic fit to temperature dependence of"
                        + " inverse of thermal action not going to work,"
                        + " as coefficients came out giving"
                        + " unextrapolatable results. Choosing"
                        + " temperature with lowest explicitly"
                        + " calculated action." )
                exclusionTemperature, currentAction = LowestAction(
                                           temperaturesWithThermalActions )
            else:
# Taking [decay width per horizon]
# = [horizon volume] * [solitonic coefficient] * exp(-[thermal action]/T)
# at temperature T, where [horizon volume] = ( M_Plank / T^2 )^3, & taking
# [solitonic coefficient] to be T^4,
# the survival probability per horizon = exp( -[time at T] / [decay time] )
# = exp( -[decay width per horizon] * ( M_Plank / T^2 ) )
# which exponents for N horizons to
# exp( -N [decay width per horizon] * ( M_Plank / T^2 ) )
# and [decay width per horizon] = M_Plank^3 T^(-2) exp(-[thermal action]/T)
# We minimize [decay width per horizon] / ( M_Plank / T^2 ) as
# exp( x( T ) ) is minimized when x( T ) is minimized, to see if the
# parameter point is excluded by thermal tunneling.
                inversePlanckFourVolume = (VPD.reducedPlanckMass)**4
                def ThermalActionOverT( T ):
                    return ( 1.0 / ( ( ( quadraticCoefficient * T * T )
                                     + ( linearCoefficient * T )
                                     + constantTerm ) * T ) )

                def ScaledDecayWithPerHorizonOverTimeAtTPlusLogarithm( T ):
                    return ( ThermalActionOverT( T )
                             + ( 4.0 * math.log( T ) ) )

                temperatureFitMinuit = minuit.Minuit( ThermalActionOverT )
                temperatureFitMinuit.values[ 'T'
                               ] = temperaturesWithThermalActions[ 1 ][ 0 ]
                try:
                    temperatureFitMinuit.migrad()
                    exclusionTemperature = temperatureFitMinuit.values[
                                                                    'T' ]
                    print( "Estimate based just on S_3/T of temperature"
                           + " with lowest survival probability is "
                           + str( exclusionTemperature )
                           + " GeV.\n\n" )
                    try:
                        temperatureFitMinuit = minuit.Minuit(
                        ScaledDecayWithPerHorizonOverTimeAtTPlusLogarithm )
                        temperatureFitMinuit.values[ 'T'
                                                   ] = exclusionTemperature
                        temperatureFitMinuit.migrad()
                        exclusionTemperature = temperatureFitMinuit.values[
                                                                    'T' ]
                        print( "Estimate based on -T^-4 exp( S_3 / T )"
                               + " of temperature with lowest survival"
                               + " probability is "
                               + str( exclusionTemperature )
                               + " GeV.\n\n" )
                    except minuit.MinuitError as minuitError:
                        print( "PyMinuit threw an exception when trying"
                               + " to minimize the thermal survival"
                               + " probability. The thermal action"
                               + " estimated from minimizing just S_3/T"
                               + " will now be used." )
                    except Exception as unexpectedException:
                        print( "Some lower-level exception happened:\n"
                               + str( unexpectedException )
                               + "\nwhile PyMinuit was trying to"
                               + " minimize the thermal survival"
                               + " probability. The thermal action"
                               + " estimated from minimizing just S_3/T"
                               + " will now be used." )
                    vcs.SetTemperature( exclusionTemperature )
                    thermalDsbVacuum = vcs.TryToMinimize( thermalDsbVacuum[
                                                        "FieldValues" ] )
                    thermalPanicVacuum = vcs.TryToMinimize(
                                    thermalPanicVacuum[ "FieldValues" ] )
                    currentThermalAction = vcs.CalculateAction(
                                            falseVacuum = thermalDsbVacuum,
                                           trueVacuum = thermalPanicVacuum,
                                                        deformPath = False,
                                                 thermalNotQuantum = True )
                    print( "\n\nCalculated thermal action = "
                           + str( currentThermalAction )
                           + " GeV." )
                    print( "Estimated thermal action  = "
                           + str( exclusionTemperature
                                  * ( temperatureFitMinuit.fval
                                      - ( 4.0
                                 * math.log( exclusionTemperature ) ) ) )
                           + " GeV.\n\n" )

                except minuit.MinuitError as minuitError:
                    print( "PyMinuit threw an exception when trying to"
                           + " minimize the thermal survival"
                           + " probability. The lowest explicitly"
                           + " calculated thermal action will now be"
                           + " used." )
                    [ exclusionTemperature,
                      currentThermalAction ] = LowestAction(
                                           temperaturesWithThermalActions )

                except Exception as unexpectedException:
                    print( "Some lower-level exception happened:\n"
                           + str( unexpectedException )
                           + "\nwhile PyMinuit was trying to"
                           + " minimize the thermal survival"
                           + " probability. The thermal action"
                           + " estimated from minimizing just S_3/T"
                           + " will now be used." )
                thermalMinimaWithTemperatures.append(
                                         { "dsbVacuum": thermalDsbVacuum,
                                       "panicVacuum": thermalPanicVacuum,
                             "temperatureValue": exclusionTemperature } )
# End of fitting the thermal action.

    exclusionTemperatureString = "unnecessary"
    quantumTunnelingTimeInUniverseAgesString = "-1.0"

    if ( not vcs.AllowedRunningTimeExceeded() ):
# Here we continue to check the zero-temperature quantum tunneling (if the
# direct path at zero temperature did not already exclude the point):
        vcs.SetTemperature( 0.0 )
        currentQuantumAction = vcs.CalculateAction(
                                               falseVacuum = vcs.dsbVacuum,
                                              trueVacuum = vcs.panicVacuum,
                                                    deformPath = True,
                                                 thermalNotQuantum = False,
                                                    maxiter2 = 3 )
# maxiter2 is a keyword argument which gets passed along to
# the CosmoTransitions fullTunneling object when it calls self.run(), which
# controls how many iterations of the outer loop of the deformation happen.
        quantumTunnelingActionType = "deformed_path"
        print( "Final deformed path zero-temperature 4-dimensional"
               + " action is "
               + str( currentQuantumAction )
               + " units of h-bar.\n\n" )
        quantumTunnelingTimeInInverseGev = (
                                      vcs.QuantumTunnelingTimeInInverseGev(
                                                   currentQuantumAction ) )
        print( "Zero-temperature tunneling time in 1/GeV = "
              + str( quantumTunnelingTimeInInverseGev ) )
        print( "Age of known Universe in 1/Gev = "
               + str( vcs.ageOfKnownUniverseInInverseGev ) )
        quantumTunnelingTimeInUniverseAges = (
                                           quantumTunnelingTimeInInverseGev
                                     / vcs.ageOfKnownUniverseInInverseGev )
        print( "Tunneling time in Universe-ages = "
              + str( quantumTunnelingTimeInUniverseAges ) )
        quantumTunnelingTimeInSeconds = str(
                                            vcs.ageOfKnownUniverseInSeconds
                                     * quantumTunnelingTimeInUniverseAges )
        print( "Zero-temperature tunneling time estimate is "
               + quantumTunnelingTimeInSeconds
               + " seconds (age of known Universe = "
               + str( vcs.ageOfKnownUniverseInSeconds )
               + " seconds).\n\n" )
        if ( currentQuantumAction < vcs.quantumActionThreshold ):
            quantumStabilityVerdict = "short-lived"
        elif ( not ( thermallyExcluded
                     or
                     vcs.AllowedRunningTimeExceeded() ) ):
# If the parameter point was not excluded just by quantum tunneling, we
# calculate whether fully deformed thermal tunneling excludes it.
            exclusionTemperature = thermalMinimaWithTemperatures[ -1 ][
                                                     "temperatureValue" ]
            thermalDsbVacuum = thermalMinimaWithTemperatures[ -1 ][
                                                            "dsbVacuum" ]
            thermalPanicVacuum = thermalMinimaWithTemperatures[ -1 ][
                                                          "panicVacuum" ]
            vcs.SetTemperature( exclusionTemperature )
            print( "Deforming tunneling path at temperature "
                   + str( exclusionTemperature )
                   + " GeV." )
            print( "At this temperature, the threshold ratio of"
                   + " 3-dimensional action to temperature is "
                   + str( vcs.thermalActionThreshold
                          / exclusionTemperature )
                   + ", hence the threshold 3-dimensional action is "
                   + str( vcs.thermalActionThreshold )
                   + " GeV.\n\n" )
            currentThermalAction = vcs.CalculateAction(
                                            falseVacuum = thermalDsbVacuum,
                                           trueVacuum = thermalPanicVacuum,
                                                        deformPath = True,
                                                  thermalNotQuantum = True,
                                                        maxiter2 = 3 )
            print( "Final 3-dimensional action  at this temperature = "
                   + str( currentThermalAction )
                   + " GeV.\n\n" )
            if ( currentThermalAction < vcs.thermalActionThreshold ):
                thermalStabilityVerdict = "low_survival_probability"

        exclusionTemperatureString = str( exclusionTemperature )
        print( "Temperature for basing thermal tunneling exclusion = "
               + exclusionTemperatureString
               + " GeV.\n\n" )

    quantumTunnelingTimeInUniverseAgesString = str(
                                       quantumTunnelingTimeInUniverseAges )
    thermalTunnelingSurvivalProbabilityString = str(
                                   vcs.ThermalTunnelingSurvivalProbability(
                                                      exclusionTemperature,
                                                   currentThermalAction ) )


# Finally the output file is written:
outputText = ( "  <reference version=\" 1.1.00beta1\""
               + " citation=\" arXiv:1307.1477 (hep-ph)\" />\n"
               + "  <stability> "
               + quantumStabilityVerdict
               + " </stability>\n"
               + "  <quantum_stability> "
               + quantumStabilityVerdict
               + " </quantum_stability>\n"
               + "  <thermal_stability> "
               + thermalStabilityVerdict
               + " </thermal_stability>\n"
               + "  <global_minimum   relative_depth=\""
               + str( vcs.panicVacuum[ "PotentialValue" ] )
               + "\" "
               + VPD.UserFieldsAsXml( vcs.panicVacuum[ "FieldValues" ] )
               + " />\n  <input_minimum   relative_depth=\""
               + str( vcs.dsbVacuum[ "PotentialValue" ] )
               + "\" "
               + VPD.UserFieldsAsXml( vcs.dsbVacuum[ "FieldValues" ] )
               + " />\n  <lifetime  action_calculation=\""
               + quantumTunnelingActionType
               + "\" > "
               + quantumTunnelingTimeInUniverseAgesString
               + " </lifetime>\n"
               + " <tunneling_temperature survival_probability=\""
               + thermalTunnelingSurvivalProbabilityString
               + "\" > "
               + exclusionTemperatureString
               + " </tunneling_temperature>" )
outputFile = open( VPD.outputFile, "w" )
outputFile.write( "<Vevacious_result>\n"
                  + outputText )# Each warning is printed as an XML element:
for warningMessage in vcs.warningMessages:
    outputFile.write( "\n  <warning>\n  "
                      + warningMessage
                      + "\n  </warning>" )
outputFile.write( "\n</Vevacious_result>\n" )
outputFile.close()
print( "Result summary (not recapping warnings):\n"       + outputText )

